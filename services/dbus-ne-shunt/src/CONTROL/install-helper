#!/bin/bash


###################################################################################
# A helper class for detecting and addusbing a serial device
# called durin installation from the opkg installer (CONTROL/postinst/prerm)

# ### Installing ###
# The script prompts the user to insert the serial usb device, so we can
# automatically detect the usb device and get teh correct bus and device id's
# and from that its tty name.
# the output from this class is are 2 files:
# \data\dbus-ne-shunt\serial-starter.rule
#   this file contains the information that gets added to the '/etc/udev/rules.d/serial-starter.rules' file
# \data\dbus-ne-shunt\serial-starter.name
#   this file contains the tty name of the device i.e. ttyACM0
# These 2 files contain enough information for the serial-starter to do its job and for us
# to start and stop the service.
# To get the serial-starter to automatically start the service, a file named
# ttyXXXX needs copying to the /dev/serial-starter/ folder. the serial-starter service will
# detect this file and  query the udevadm and start the service, without the need to reboot

# ### firmware uodates ####
# After a firmware update the service is no longer installed.
# Our 2 files are still availible under the /data folder as 
# this folder is not effected by firmware updates.
# If ensure-installed is setup (see postinst) to run from /data/rS.local then
# the service will automatically be downloaded and restored using the data in data/dbus-ne-shunt.

# ### Removing ###
# When uninstalling the two files serial-starter.rules & serial-starter.name are also removed
# See the 'prerm' file for the script code for calling the class.

# ### Notes ###
# The sausage machine looks like this
# The serial-starter.rules file contains the rules for which usb device is mapped to which service
# ENV{VE_SERVICE} conatins the mapping name of the service.
# The VE_SERVICE variable gets mapped to the actual service folder name
# The file '/etc/venus/serial-starter.conf' contains this mapping 
# VE_SERVICE        SERVICE_FOLDER_NAME
# Example
# neshunt           dbus-ne-shunt
# From this mapping the serial-starter service looks for the 'dbus-ne-shunt' folder 
# under /opt/victronenergy/service-templates/ and calls the run script file.
# The run script file then calls /opt/victronenergy/dbus-ne-shunt/start-dbus-ne-shunt.sh 
# Note the serial-starter also does some other tasks as well.
# see /opt/victronenergy/serial-starter/serial-starter.sh code for more details
###################################################################################

# shellcheck disable=SC2034
VERSION="2.0.0"

SERIAL_STARTER_RULES_TEXT_MATCH='RUN+="/opt/victronenergy/serial-starter/cleanup.sh %k"'

init_default_path_variables() {
    SERIAL_STARTER_RULES_FILE="/etc/udev/rules.d/serial-starter.rules"
    SERIAL_STARTER_CONFIG_FILE="/etc/venus/serial-starter.conf"
    RC_LOCAL_FILE="/data/rc.local"
}

 
_log() {
    local msg="$1"
    local dbusMsg="$2"
 
    if [[ -n "$DBUS_MESSAGE_PATH" ]]; then
        [[ -z "$dbusMsg" ]] && dbusMsg="$msg"
        dbus-send --system --print-reply --dest="$DBUS_MESSAGE_PATH" com.victronenergy.BusItem.SetValue variant:string:"$dbusMsg"
    fi

    if [ -z "$2" ]; then 
        echo "$msg" > /dev/tty
    else
        echo -ne "$msg" > /dev/tty # overwrite existing 
    fi
    
}
 
_detect_inserted_serial_usb_device() {
    local counter=0
    
    local timeout_counter=0
    local progress_header_msg="Please connect the serial device (or remove and reconnect it) to the USB port."
    local before_usb_devices
    before_usb_devices=$(lsusb)

    _log "$progress_header_msg"
    _log "Waiting for USB device to be connected..."

    while true; do
        sleep 1
        local after_usb_devices
        after_usb_devices=$(lsusb)
        local before_count after_count
        
        before_count=$(echo "$before_usb_devices" | wc -l)
        after_count=$(echo "$after_usb_devices" | wc -l)
        if [[ $after_count -eq $((before_count + 1)) ]]; then
            local new_device
            new_device=$(comm -13 <(echo "$before_usb_devices") <(echo "$after_usb_devices"))
            echo "$new_device"
            return
        else
            before_usb_devices="$after_usb_devices"
            if [[ $timeout_counter -eq 4 && -n "$TEST_USB_ID" ]]; then
                local test_line
                test_line=$(echo "$after_usb_devices" | grep "$TEST_USB_ID")
                if [[ -n "$test_line" ]]; then 
                    echo "$test_line"
                    return
                fi
            fi
        fi
        counter=$((counter + 1))
        [[ $counter -gt 3 ]] && counter=1
        timeout_counter=$((timeout_counter + 1))
        if [[ $timeout_counter -gt 60 ]]; then
            _log "Timeout, exiting..."
            echo ""
            return
        fi
        _log "No new USB device detected, retrying$(printf '.%.0s' $(seq 1 $counter))  " true
    done
}


_create_tty_file() {

    if [[ -f "$TTY_FILE" ]]; then
        _log "found existing serial-starter.devname: $TTY_FILE"
        USED_TTY_FILE=1
        TTY=$(cat "$TTY_FILE")
        return 0
    fi
 
    local usb_device
    usb_device=$(_detect_inserted_serial_usb_device)
    [[ -z "$usb_device" ]] && _log "No new USB device found." && echo "" && return
    
    _log "Found new USB device: $usb_device"

    local parts bus device
    read -ra parts <<< "$usb_device"
    bus="${parts[1]}"
    device="${parts[3]%:}"
    TTY=$(udevadm info --query=path --name="/dev/bus/usb/$bus/$device" | xargs -I% find "/sys%" -name 'device' | xargs dirname | xargs basename)
    
    echo "$TTY" > "$TTY_FILE"
    echo "$TTY"
}

_create_serial_starter_rule() {
 
    # shellcheck disable=SC2153
    if [[ -f "$SERIAL_STARTER_RULE_FILE" ]]; then
        _log "found existing serial-starter.rule: $SERIAL_STARTER_RULE_FILE"
        USED_SERIAL_STARTER_RULE_FILE=1
        return 0
    fi

    local usb_info_lines matches usb_rule
    usb_info_lines=$(udevadm info --name="/dev/$TTY" --query=property | grep "ID_BUS=\|ID_VENDOR=\|ID_MODEL=\|ID_SERIAL=")
    matches=""
    while IFS= read -r line; do
        name="${line%%=*}"
        value="${line#*=}"
        [[ -n "$matches" ]] && matches+=", "
        matches+="ENV{$name}==\"$value\""
    done <<< "$usb_info_lines"
    if [[ -z "$matches" ]]; then
        _log "warning: No serial ID found for the device."
        return 1
    fi
    usb_rule="# $SERVICE_NAME\nACTION==\"add\", $matches, ENV{VE_SERVICE}=\"$VE_SERVICE_MAPPING_NAME\""
    echo -e "$usb_rule" > "$SERIAL_STARTER_RULE_FILE"
    return 0
}

get_USED_SERIAL_STARTER_RULE_FILE() {
    echo "$USED_SERIAL_STARTER_RULE_FILE"
}

get_USED_TTY_FILE() {
    echo "$USED_TTY_FILE"
}

_do_serial_starter_rule_files_exist() {
    [[ ! -f "$SERIAL_STARTER_RULES_FILE" ]] && _log "Error: $SERIAL_STARTER_RULES_FILE does not exist." && return 1
    [[ ! -f "$SERIAL_STARTER_RULE_FILE" ]] && _log "Warning: $SERIAL_STARTER_RULE_FILE does not exist." && return 1
    return 0
}

_add_rule_to_serial_starter_rules_file() {
    _do_serial_starter_rule_files_exist || return 1
    local rules rule
    rules=$(cat "$SERIAL_STARTER_RULES_FILE")
    rule=$(cat "$SERIAL_STARTER_RULE_FILE")
    if grep -qF "$rule" "$SERIAL_STARTER_RULES_FILE"; then
        _log "Rule already exists in the file."
        return 0
    fi
    _log "Adding new rule to serial starter rules file..."
    local new_rules found=0
    while IFS= read -r line; do
        if [[ "$line" == *"$SERIAL_STARTER_RULES_TEXT_MATCH" ]]; then
            new_rules+="$line\n$rule\n"
            found=1
        else
            new_rules+="$line\n"
        fi
    done <<< "$rules"
    [[ $found -eq 0 ]] && return 1
    echo -e "$new_rules" > "$SERIAL_STARTER_RULES_FILE"
    _log "Rule added successfully."
    return 0
}

_remove_string_with_newline_variants() {
    local source="$1"
    local string_to_remove="$2"
    source=${source/"\n$string_to_remove\n"/}
    source=${source/"\n$string_to_remove"/}
    source=${source/"\n$string_to_remove\n/"}
    source=${source/"$string_to_remove"/}
    echo "$source"
}

_remove_rule_from_serial_starter_rules_file() {
    _do_serial_starter_rule_files_exist || { _log "Warning: Could not remove rule from $SERIAL_STARTER_RULES_FILE. Please manualy update"; return; }
    local rules rule
    rules=$(cat "$SERIAL_STARTER_RULES_FILE")
    rule=$(cat "$SERIAL_STARTER_RULE_FILE")
    local new_rules
    new_rules=$(_remove_string_with_newline_variants "$rules" "$rule")
    if [[ "$new_rules" != "$rules" ]]; then
        echo -e "$new_rules" > "$SERIAL_STARTER_RULES_FILE"
        _log "successfully removed rule from $SERIAL_STARTER_RULES_FILE"
    else
        _log "warning rule not removed rule from $SERIAL_STARTER_RULES_FILE"
    fi
    rm -f "$SERIAL_STARTER_RULE_FILE"
}

_remove_tty_name_file() {
    [[ ! -f "$TTY_FILE" ]] && _log "Warning: Could not remove tty name file '$TTY_FILE'" && return
    rm -f "$TTY_FILE"
}
 
install_usb_serial_device() {

    _log "Installing USB serial device..."
 
    _create_tty_file
 
    [[ -z "$TTY" ]] && return 1

    _create_serial_starter_rule || return 1

    _add_rule_to_serial_starter_rules_file || { _log "Could not update $SERIAL_STARTER_RULES_FILE. Please manualy update"; }

    return 0
}

remove_usb_serial_device() { 
    _remove_rule_from_serial_starter_rules_file
    _remove_tty_name_file
}

################################################
# Add service mapping to serial starter conf file
################################################
add_ve_service_config_file_mapping() {

    local config
    config="service $VE_SERVICE_MAPPING_NAME"$'\t\t'"$SERVICE_NAME"
    
    if ! grep -q "^$config$" "$SERIAL_STARTER_CONFIG_FILE"; then
        _log "adding service mapping config from $SERIAL_STARTER_CONFIG_FILE"
        sed -i '1s/^/'"${config}"'\n/' "$SERIAL_STARTER_CONFIG_FILE"
    fi
}

remove_ve_service_config_file_mapping() {
    local config
    config="service $VE_SERVICE_MAPPING_NAME"$'\t\t'"$SERVICE_NAME"
  
    if grep -q "^$config$" "$SERIAL_STARTER_CONFIG_FILE"; then
        _log "removing service mapping config from $SERIAL_STARTER_CONFIG_FILE"
        sed -i '/^'"$config"'/d' "$SERIAL_STARTER_CONFIG_FILE"
    fi
}

################################################
# Adding ensure-installed to rc.local
################################################
add_ensure_installed_script_to_rc_local() {
  
    local rc_local_script
    rc_local_script="/data/$SERVICE_NAME/ensure-installed"

    if ! grep -q "^$rc_local_script$" "$RC_LOCAL_FILE"; then
        _log "adding $rc_local_script} to $RC_LOCAL_FILE"
        echo "$rc_local_script" >> "$RC_LOCAL_FILE"
        chmod +x "$RC_LOCAL_FILE"
    fi
}

remove_ensure_installed_script_from_rc_local() {
    
    local rc_local_script
    rc_local_script="/data/$SERVICE_NAME/ensure-installed"

    if ! grep -q "^$rc_local_script$" "$RC_LOCAL_FILE"; then
        echo "Removing $rc_local_script from $RC_LOCAL_FILE"
        sed -i '/^'"$rc_local_script"'/d' "$RC_LOCAL_FILE"
    fi
}
################################################
# Add a file (ttyACME) to /dev/serial-starter/
# this file is picked up by the serial-starter
# and starts the service
################################################
start_service() {
 
    if [ -f "$TTY_FILE" ]; then
        
        #tty=$(<"$TTY_FILE")
        _log "starting service /service/$SERVICE_NAME.$TTY"
        touch "/dev/serial-starter/$TTY"
    else
        _log "warning: cannot start service $SERVICE_NAME - $TTY_FILE file not found" 
    fi
}


stop_and_remove_service() {
    
  ################################################
  # Stop the service
  # Reads the tty name from the serial-starter.devname
  # file and combines it with the SERVICE_NAME to make
  # the full service name i.e. dbus-ne-shunt.ttyACM0
  ################################################
  if [ -f "$TTY_FILE" ]; then
    local full_service_name
    full_service_name=/service/"$SERVICE_NAME".$(<"$TTY_FILE")
    if [ -d "$full_service_name" ]; then
      _log "stopping service $full_service_name"
      svc -d "$full_service_name" 2>/dev/null
      sleep 3 # secs
      rm -R "$full_service_name" 2>/dev/null
    else
      _log "not found service $full_service_name"
    fi
  else
    _log "not found $TTY_FILE"
  fi
}
